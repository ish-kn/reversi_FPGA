
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module reversi_FPGA(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// KEY //////////
	KEY,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// RS232 //////////
	UART_CTS,
	UART_RTS,
	UART_RXD,
	UART_TXD 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input		          		CLOCK_50;
input		          		CLOCK2_50;
input		          		CLOCK3_50;

//////////// KEY //////////
input		     [3:0]		KEY;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// RS232 //////////
output		          		UART_CTS;
input		          		UART_RTS;
input		          		UART_RXD;
output		          		UART_TXD;


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire rx, tx;
wire end_flag, win_white;
wire [7:0] cnt_white, cnt_black, cnt_total;
wire [63:0] WhiteData, BlackData;

//=======================================================
//  Structural coding
//=======================================================

// RS232
assign rx = UART_RXD;
assign UART_TXD = tx;
// LCD
assign	LCD_ON		=	1'b1;
assign	LCD_BLON	=	1'b1;
// reversi
assign cnt_total = cnt_white + cnt_black;
assign end_flag = (cnt_total == 8'd64) ? 1'b1 : 1'b0;
assign win_white = (cnt_white > cnt_black) ? 1'b1 : 1'b0;

reversi #(.sys_clk(50000000), .rate(19200), .MAX_TRY_NUM(10000))
		U0(.pClk(CLOCK_50), .pRxD(rx), .pTxD(tx), .pReset(KEY[0]),
		.WhiteData(WhiteData), .BlackData(BlackData));
		
cnt_data U1(.WhiteData(WhiteData), .BlackData(BlackData),
			.cnt_white(cnt_white), .cnt_black(cnt_black));
			
SEG7_LUT U2(.iDIG(cnt_black[7:0]/8'd10), .oSEG(HEX7));
SEG7_LUT U3(.iDIG(cnt_black[7:0]%8'd10), .oSEG(HEX6));
SEG7_LUT U4(.iDIG(cnt_white[7:0]/8'd10), .oSEG(HEX5));
SEG7_LUT U5(.iDIG(cnt_white[7:0]%8'd10), .oSEG(HEX4));
SEG7_LUT U6(.iDIG(4'd0), .oSEG(HEX3));
SEG7_LUT U7(.iDIG(4'd0), .oSEG(HEX2));
SEG7_LUT U8(.iDIG(cnt_total/8'd10), .oSEG(HEX1));
SEG7_LUT U9(.iDIG(cnt_total%8'd10), .oSEG(HEX0));

LCD_reversi	U10	(	
				//	Host Side
				.iCLK  	 ( CLOCK_50 ),
				.iRST_N	 ( KEY[0] ),
				.end_flag( end_flag ),
				.win_white( win_white ),
				//	LCD Side
				.LCD_DATA ( LCD_DATA ),
				.LCD_RW   ( LCD_RW ),
				.LCD_EN	 ( LCD_EN ),
				.LCD_RS   ( LCD_RS )	
				);
endmodule
